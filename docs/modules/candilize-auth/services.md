# Services — AuthService & ConfigService

## AuthService

**File**: `candilize-auth/src/main/java/com/mohsindev/candilize/auth/service/AuthService.java`

### What This File Does

The AuthService handles user registration, login authentication, and token refresh. It's the core business logic for authentication.

### Full Source with Commentary

```java
@Slf4j                                                        // 1
@Service                                                       // 2
@RequiredArgsConstructor                                       // 3
public class AuthService {

    private final UserRepository userRepository;               // 4
    private final PasswordEncoder passwordEncoder;             // 5
    private final JwtTokenProvider jwtTokenProvider;            // 6
    private final AuthenticationManager authenticationManager;  // 7
    private final UserDetailsService userDetailsService;        // 8

    @Value("${app.jwt.access-token-expiration}")               // 9
    private long accessTokenExpirationMs;

    @Transactional                                             // 10
    public void register(RegisterRequest request) {
        if (userRepository.existsByUsername(request.username())) {  // 11
            throw new IllegalArgumentException(
                "Username already exists: " + request.username());
        }
        if (userRepository.existsByEmail(request.email())) {
            throw new IllegalArgumentException(
                "Email already exists: " + request.email());
        }
        UserEntity user = UserEntity.builder()                 // 12
            .username(request.username())
            .email(request.email())
            .password(passwordEncoder.encode(request.password()))  // 13
            .role(UserEntity.Role.ROLE_USER)                   // 14
            .enabled(true)
            .build();
        userRepository.save(user);                             // 15
        log.info("Registered user: {}", request.username());
    }

    public AuthResponse login(LoginRequest request) {
        authenticationManager.authenticate(                    // 16
            new UsernamePasswordAuthenticationToken(
                request.username(), request.password()));
        UserDetails userDetails =
            userDetailsService.loadUserByUsername(
                request.username());                           // 17
        String accessToken =
            jwtTokenProvider.generateAccessToken(userDetails);  // 18
        String refreshToken =
            jwtTokenProvider.generateRefreshToken(userDetails);
        return AuthResponse.of(accessToken, refreshToken,
            accessTokenExpirationMs / 1000);                   // 19
    }

    public AuthResponse refreshToken(String refreshToken) {
        if (!jwtTokenProvider.validateToken(refreshToken)) {   // 20
            throw new IllegalArgumentException(
                "Invalid refresh token");
        }
        String username =
            jwtTokenProvider.getUsernameFromToken(refreshToken);  // 21
        UserDetails userDetails =
            userDetailsService.loadUserByUsername(username);
        String newAccessToken =
            jwtTokenProvider.generateAccessToken(userDetails);
        String newRefreshToken =
            jwtTokenProvider.generateRefreshToken(userDetails);
        return AuthResponse.of(newAccessToken, newRefreshToken,
            accessTokenExpirationMs / 1000);
    }
}
```

### Key Lines Explained

**Line 1**: `@Slf4j` — Lombok generates `private static final Logger log = LoggerFactory.getLogger(AuthService.class)`. You can use `log.info(...)`, `log.warn(...)`, etc. without declaring the logger yourself.

**Line 2**: `@Service` — registers this as a Spring-managed bean. Functionally identical to `@Component`, but semantically indicates a service-layer class.

**Line 3**: `@RequiredArgsConstructor` — generates a constructor with all 5 `final` fields as parameters. Spring injects all 5 beans when creating this service.

**Lines 4-8**: Five injected dependencies:

| Field | Type | What it is | Where it comes from |
|---|---|---|---|
| `userRepository` | `UserRepository` | JPA repository for database access | Auto-generated by Spring Data JPA |
| `passwordEncoder` | `PasswordEncoder` | BCrypt hasher | `SecurityConfig.passwordEncoder()` bean |
| `jwtTokenProvider` | `JwtTokenProvider` | JWT token creator/validator | `@Component` class |
| `authenticationManager` | `AuthenticationManager` | Spring Security authentication | `SecurityConfig.authenticationManager()` bean |
| `userDetailsService` | `UserDetailsService` | Loads users from DB for Spring Security | `UserDetailsServiceImpl` (`@Service` class) |

**Line 9**: `@Value("${app.jwt.access-token-expiration}")` — injects a config value. Note: `@Value` can only inject into fields or constructor parameters. It cannot be used on `final` fields when also using `@RequiredArgsConstructor` (because Lombok's constructor runs before `@Value` is processed). That's why `accessTokenExpirationMs` is NOT `final`.

**Line 10**: `@Transactional` — wraps the entire method in a database transaction. If any exception is thrown, all database changes are rolled back. This ensures atomicity — either the user is fully registered, or nothing happens.

**Line 11**: `userRepository.existsByUsername(request.username())` — Spring Data JPA **derives the SQL query from the method name**:
- `existsBy` → `SELECT COUNT(*) > 0 FROM`
- `Username` → `WHERE username = ?`
- Final SQL: `SELECT COUNT(*) > 0 FROM users WHERE username = ?`

You don't write SQL — Spring generates it from the method name. This is called **query derivation**.

**Line 12**: `UserEntity.builder()` — Lombok's `@Builder` generates a builder class. This is the builder pattern — instead of a constructor with many parameters, you chain method calls.

**Line 13**: `passwordEncoder.encode(request.password())` — hashes the password with BCrypt. The result looks like `$2a$10$8K1p/a0dL1LXMIg...`. BCrypt automatically generates a random salt, so the same password produces different hashes each time.

**Line 14**: `.role(UserEntity.Role.ROLE_USER)` — all new users get `ROLE_USER`. Only the seed migration creates `ROLE_ADMIN` users.

**Line 15**: `userRepository.save(user)` — JPA saves the entity to MySQL. Since `id` is null, it performs an `INSERT`. If `id` were set, it would perform an `UPDATE`.

**Line 16**: `authenticationManager.authenticate(...)` — this is the heart of login. The `AuthenticationManager` (provided by Spring Security):
1. Creates a `UsernamePasswordAuthenticationToken` with the submitted credentials
2. Calls `UserDetailsServiceImpl.loadUserByUsername()` to get the stored user
3. Uses `BCryptPasswordEncoder.matches()` to compare the submitted password with the stored hash
4. If they match → returns an authenticated token
5. If they don't → throws `BadCredentialsException` (caught by `GlobalExceptionHandler`)

**Line 17-19**: After successful authentication:
1. Load full user details (username, roles)
2. Generate access token (15 min) and refresh token (7 days)
3. Return both tokens to the client, with `expiresIn` in seconds

**Lines 20-21**: Refresh flow:
1. Validate the refresh token (check signature + expiration)
2. Extract username from the token
3. Generate new tokens
4. The old refresh token is not invalidated — this is a common simplification

---

## ConfigService

**File**: `candilize-auth/src/main/java/com/mohsindev/candilize/auth/service/ConfigService.java`

### What This File Does

Manages trading pair and interval configuration with Redis caching.

### Key Methods with Commentary

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class ConfigService {

    private final SupportedPairRepository pairRepository;
    private final SupportedIntervalRepository intervalRepository;

    @Transactional(readOnly = true)                            // 1
    @Cacheable(value = "supportedPairs", key = "'all'")        // 2
    public List<PairResponse> getAllPairs() {
        return pairRepository.findAll().stream()
            .map(this::toPairResponse)                         // 3
            .collect(Collectors.toList());
    }

    @Transactional
    @CacheEvict(value = "supportedPairs", allEntries = true)   // 4
    public PairResponse addPair(PairRequest request) {
        if (pairRepository.findBySymbol(request.symbol())
                .isPresent()) {
            throw new IllegalArgumentException(
                "Pair already exists: " + request.symbol());
        }
        SupportedPairEntity entity = SupportedPairEntity.builder()
            .symbol(request.symbol().toUpperCase())            // 5
            .baseAsset(request.baseAsset().toUpperCase())
            .quoteAsset(request.quoteAsset().toUpperCase())
            .enabled(true)
            .build();
        entity = pairRepository.save(entity);
        log.info("Added pair: {}", entity.getSymbol());
        return toPairResponse(entity);
    }
```

### Caching Explained

**Line 1**: `@Transactional(readOnly = true)` — opens a read-only transaction. `readOnly = true` is an optimization hint — Hibernate doesn't track entity changes (dirty checking), which saves memory and CPU.

**Line 2**: `@Cacheable(value = "supportedPairs", key = "'all'")` — Spring caching annotation:
- Before running the method, Spring checks Redis for key `supportedPairs::all`
- If found → returns the cached value immediately (skips the method)
- If not found → runs the method, stores the result in Redis, then returns it
- Cache TTL is 300 seconds (configured in `CacheConfig`)

**Line 3**: `this::toPairResponse` — a method reference. Shorthand for `entity -> toPairResponse(entity)`. The `toPairResponse` method converts a JPA entity to a response DTO.

**Line 4**: `@CacheEvict(value = "supportedPairs", allEntries = true)` — when a pair is added, modified, or deleted, this clears the entire `supportedPairs` cache. Next time `getAllPairs()` is called, it will hit the database and re-cache.

**Line 5**: `.toUpperCase()` — normalizes symbols. Whether the admin enters `btcusdt` or `BTCUSDT`, it's stored as `BTCUSDT`.

### The Scheduler Config Method

```java
@Transactional(readOnly = true)
public SchedulerConfigResponse getSchedulerConfig() {
    List<SupportedPairEntity> pairs =
        pairRepository.findAllByEnabledTrue();              // 1
    List<SupportedIntervalEntity> intervals =
        intervalRepository.findAllByEnabledTrue();          // 2
    return new SchedulerConfigResponse(
        pairs.stream().map(p ->
            new SchedulerConfigResponse.SchedulerPair(
                p.getSymbol(), p.getBaseAsset(),
                p.getQuoteAsset())).toList(),
        intervals.stream().map(i ->
            new SchedulerConfigResponse.SchedulerInterval(
                i.getIntervalCode())).toList());
}
```

**Line 1**: `findAllByEnabledTrue()` — another derived query:
- `findAllBy` → `SELECT * FROM ... WHERE`
- `Enabled` → `enabled`
- `True` → `= true`
- Final SQL: `SELECT * FROM supported_pairs WHERE enabled = true`

Only enabled pairs/intervals are returned to the scheduler.
